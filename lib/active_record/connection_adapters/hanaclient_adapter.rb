require "singleton"

require 'arel/visitors/hanaclient'

require "active_record/connection_adapters/abstract_adapter"
require "active_record/connection_adapters/statement_pool"

require "active_record/connection_adapters/hanaclient/column"
require "active_record/connection_adapters/hanaclient/database_statements"
require "active_record/connection_adapters/hanaclient/quoting"
require "active_record/connection_adapters/hanaclient/schema_creation"
require "active_record/connection_adapters/hanaclient/schema_definitions"
require "active_record/connection_adapters/hanaclient/schema_statements"
require "active_record/connection_adapters/hanaclient/transaction"
require "active_record/connection_adapters/hanaclient/type_metadata"

require "hanaclient"
# Singleton class to hold a valid instance of the HANACLIENTInterface across all connections
class HA
  include Singleton
  attr_accessor :api

  @@dbcapi_path = nil
  def self.dbcapi_path= path
    @@dbcapi_path = path
  end

  def initialize
    @api = HANACLIENT::HANACLIENTInterface.new()
    HANACLIENT::API.hanaclient_initialize_interface(@api, @@dbcapi_path)
    raise LoadError, "Could not initialize HANA client library" if @api.hanaclient_init() == 0
    ObjectSpace.define_finalizer(self, HA.finalize(@api))
  end

  # Returns a proc that is run when this object is destroyed
  def self.finalize(api)
    proc{
      api.hanaclient_fini()
      HANACLIENT::API.hanaclient_finalize_interface( api )
    }
  end
end

module ActiveRecord
  module ConnectionHandling
    # Establishes a connection to the database that's used by all Active Record objects
    def hanaclient_connection(config)
      HA.dbcapi_path = config[:dbcapi_path]

      db = HA.instance.api.hanaclient_new_connection()

      connection_string = "SERVERNODE=#{config[:server]}"
      connection_string += ":#{config[:port]}" if config[:port]
      connection_string += ";UID=#{config[:username]};PWD=#{config[:password]};"
      connection_string += "DATABASENAME=#{config[:database]};" if config[:database]
      # overrides the database option in connection properties if the database option is explicity given
      connection_string += (config[:database] ? config[:connection_properties].gsub(/databasename=[^;]*;/i, "") : config[:connection_properties]) if config[:connection_properties]

      ConnectionAdapters::HanaclientAdapter.new(db, logger, connection_string, config)
    end
  end

  module ConnectionAdapters

    class HanaclientAdapter < AbstractAdapter
      ADAPTER_NAME = "Hanaclient".freeze

      include ActiveRecord::ConnectionAdapters::Hanaclient::DatabaseStatements
      include ActiveRecord::ConnectionAdapters::Hanaclient::SchemaStatements
      include ActiveRecord::ConnectionAdapters::Hanaclient::Quoting

      # Supports all standard activerecord types and unicode
      NATIVE_DATABASE_TYPES = {
        primary_key: "BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY",
        string:      { name: "VARCHAR", limit: 3000 },
        integer:     { name: "INTEGER", limit: 8 },
        float:       { name: "FLOAT", limit: 53 },
        decimal:     { name: "DECIMAL" },
        time:        { name: "TIME" },
        date:        { name: "DATE" },
        seconddate:  { name: "SECONDDATE" },
        timestamp:   { name: "TIMESTAMP" },
        binary:      { name: "VARBINARY", limit: 3000 },
        unicode:     { name: "NVARCHAR", limit: 3000 },
        text:        { name: "CLOB" },
        boolean:     { name: "BOOLEAN" }
      }

      class StatementPool < ConnectionAdapters::StatementPool
        private

          def dealloc(stmt)
            HA.instance.api.hanaclient_free_stmt(stmt)
          end
      end

      def schema_creation
        Hanaclient::SchemaCreation.new self
      end

      def arel_visitor
        Arel::Visitors::Hanaclient.new(self)
      end

      def initialize( connection, logger, connection_string, config) #:nodoc:
        super(connection, logger, config)

        @statements = StatementPool.new(self.class.type_cast_config_to_integer(config[:statement_limit]))

        @connection_string = connection_string

        @affected_rows = 0
        connect!
      end

      def supports_foreign_keys?
        true
      end

      def active?
        result = HA.instance.api.hanaclient_execute_immediate(@connection, "SELECT 1 FROM DUMMY") == 1
      end

      def connect!
        result = HA.instance.api.hanaclient_connect(@connection, @connection_string)
        unless result == 1
          result, error = HA.instance.api.hanaclient_error(@connection)
          raise ActiveRecord::StatementInvalid.new(error)
        end
      end

      def reconnect!
        super
        disconnect!
        connect!
      end

      def disconnect!
        super
        HA.instance.api.hanaclient_disconnect( @connection )
      end

      def clear_cache!
        @statements.clear
      end

      def native_database_types
        NATIVE_DATABASE_TYPES
      end

      # Creates a new column object given a hanaclient response statement (field)
      def new_column_from_field(table_name, field)
        name = field[3]
        default = field[11]
        sql_type_metadata = fetch_type_metadata(field[6])
        nullable = field[10] == "TRUE"
        table_name = field[1]
        collation = field[12]
        Hanaclient::Column.new(name, default, sql_type_metadata, nullable, table_name, nil, collation, comment: nil)
      end

      # Returns the primary keys of a given table
      def primary_keys(table_name)
        raise ArgumentError unless table_name.present?

        scope = quoted_scope(table_name)

        column_names = query_values(<<-SQL.strip_heredoc, "SCHEMA")
          SELECT COLUMN_NAME
          FROM SYS.INDEX_COLUMNS
          WHERE CONSTRAINT = 'PRIMARY KEY'
            AND SCHEMA_NAME = #{scope[:schema]}
            AND TABLE_NAME = #{scope[:name]}
          ORDER BY POSITION
        SQL

        column_names.map{|name| name}
      end

      private
        def initialize_type_map(m)
          super
          m.register_type %r(date)i,         Type::Date.new
          m.register_type %r(time)i,         Type::Time.new
          m.register_type %r(seconddate)i,   Type::DateTime.new
          m.register_type %r(timestamp)i,    Type::DateTime.new

          m.register_type %r(bigint)i,       Type::Integer.new(limit: 8)
          m.register_type %r(integer)i,      Type::Integer.new(limit: 4)
          m.register_type %r(smallint)i,     Type::Integer.new(limit: 2)
          m.register_type %r(tinyint)i,      Type::UnsignedInteger.new(limit: 1)

          m.register_type %r(decimal)i,      Type::Decimal.new
          m.register_type %r(real)i,         Type::Float.new
          m.register_type %r(double)i,       Type::Float.new

          m.register_type %r(boolean)i,      Type::Boolean.new

          m.register_type %r(varchar)i,      Type::String.new(limit: 5000)
          m.register_type %r(nvarchar)i,     Type::String.new(limit: 5000)
          m.register_type %r(alphanum)i,     Type::String.new(limit: 127)
          m.register_type %r(varbinary)i,    Type::Binary.new(limit: 5000)

          m.register_type %r(blob)i,         Type::Text.new(limit: 2**31 - 1)
          m.register_type %r(clob)i,         Type::Text.new(limit: 2**31 - 1)
          m.register_type %r(nlob)i,         Type::Text.new(limit: 2**31 - 1)
        end

        # Returns column information for a given table
        def column_definitions(table_name)
          scope = quoted_scope(table_name)

          query(<<-end_sql, "SCHEMA")
            SELECT * FROM SYS.TABLE_COLUMNS WHERE TABLE_NAME = #{scope[:name]} AND SCHEMA_NAME = #{scope[:schema]} ORDER BY POSITION
          end_sql
        end

        def create_table_definition(*args)
          Hanaclient::TableDefinition.new(*args)
        end

        def extract_table_ref_from_insert_sql(sql)
          sql[/into\s("[A-Za-z0-9_."\[\]\s]+"|[A-Za-z0-9_."\[\]]+)\s*/im]
          $1.strip if $1
        end

        def last_insert_id_result(sequence_name)
          exec_query("SELECT #{quote_table_name(sequence_name)}.CURRVAL FROM DUMMY", "SQL")
        end

        # Executes an sql statement and frees the statement
        def exec_and_clear(sql, name = "SQL", binds = [], prepare: false)
          type_casted_binds = type_casted_binds(binds)

          log(sql, name, binds, type_casted_binds) do
            cached = false

            # Statement caching seems to have issues. Don't use for now
            # if without_prepared_statement?(binds)
              stmt = HA.instance.api.hanaclient_prepare(@connection, sql)
              if stmt.nil?
                result, errstr = HA.instance.api.hanaclient_error(@connection)
                raise ActiveRecord::StatementInvalid.new(errstr)
              end
            # else
            #   unless @statements.key? sql
            #     @statements[sql] = HA.instance.api.hanaclient_prepare(@connection, sql)
            #     if @statements[sql].nil?
            #       result, errstr = HA.instance.api.hanaclient_error(@connection)
            #       raise ActiveRecord::StatementInvalid.new(errstr)
            #     end
            #   end
            #   stmt = @statements[sql]
            #   cached = true
            # end

            num_params = HA.instance.api.hanaclient_num_params(stmt)

            num_params.times do |i|
              res, param = HA.instance.api.hanaclient_describe_bind_param(stmt, i)
              param.set_value(type_casted_binds[i])
              HA.instance.api.hanaclient_bind_param(stmt, i, param)
            end

            if HA.instance.api.hanaclient_execute(stmt) == 0
              result, errstr = HA.instance.api.hanaclient_error(@connection)
              raise ActiveRecord::StatementInvalid.new(errstr)
            end

            ret = yield stmt
            HA.instance.api.hanaclient_free_stmt(stmt) unless cached
            ret
          end
        end

    end
  end
end
